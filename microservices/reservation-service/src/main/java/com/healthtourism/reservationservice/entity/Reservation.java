package com.healthtourism.reservationservice.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Reservation Entity - Professional Enterprise Implementation
 * 
 * Best Practices Applied:
 * - Audit fields (createdAt, updatedAt, createdBy, updatedBy) - JPA Auditing
 * - Soft delete (@SQLDelete, @Where) - prevents data loss
 * - Status Enum - type safety and business logic
 * - BigDecimal for currency - precision for financial data
 * - Database indexes - query performance
 * - Lazy loading - prevents N+1 problems
 * - Column constraints - data integrity
 * - Business logic methods - calculateTotal()
 * - Unique reservation number - human-readable format
 * 
 * Note: In a microservice architecture, relationships are via IDs (not @ManyToOne)
 * to avoid cross-service dependencies. However, if entities are in the same service,
 * @ManyToOne with LAZY can be used.
 */
@Entity
@Table(name = "reservations", indexes = {
    @Index(name = "idx_res_number", columnList = "reservation_number", unique = true),
    @Index(name = "idx_res_status", columnList = "status"),
    @Index(name = "idx_res_user_id", columnList = "user_id"),
    @Index(name = "idx_res_doctor_id", columnList = "doctor_id"),
    @Index(name = "idx_res_hospital_id", columnList = "hospital_id"),
    @Index(name = "idx_res_appointment_date", columnList = "appointment_date"),
    @Index(name = "idx_res_status_date", columnList = "status, appointment_date"),
    @Index(name = "idx_res_doctor_date", columnList = "doctor_id, appointment_date"),
    @Index(name = "idx_res_deleted", columnList = "deleted")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EntityListeners(AuditingEntityListener.class) // Enable JPA Auditing
@SQLDelete(sql = "UPDATE reservations SET deleted = true, updated_at = CURRENT_TIMESTAMP WHERE id = ?")
@Where(clause = "deleted = false")
@ToString(exclude = {"user", "doctor", "hospital", "accommodation"}) // Exclude relationships from toString
public class Reservation {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * Audit: When the entity was created
     * Automatically populated by JPA Auditing (@CreatedDate)
     */
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    /**
     * Audit: Who created the entity (user identifier - UUID, email, or username)
     * Automatically populated by JPA Auditing (@CreatedBy)
     */
    @CreatedBy
    @Column(name = "created_by", length = 255)
    private String createdBy;
    
    /**
     * Audit: When the entity was last updated
     * Automatically populated by JPA Auditing (@LastModifiedDate)
     */
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    /**
     * Audit: Who last updated the entity (user identifier - UUID, email, or username)
     * Automatically populated by JPA Auditing (@LastModifiedBy)
     */
    @LastModifiedBy
    @Column(name = "updated_by", length = 255)
    private String updatedBy;
    
    /**
     * Soft Delete: Flag to mark entity as deleted without physical deletion
     * Critical for healthcare data - records should never be physically deleted
     */
    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private Boolean deleted = false;
    
    /**
     * Optimistic Locking: Version field for concurrent access control
     * Prevents lost updates in concurrent scenarios
     */
    @Version
    @Column(name = "version")
    private Long version;
    
    /**
     * Unique reservation number - Human-readable format
     * Format: HT-YYYY-MMDD-XXXX (e.g., HT-2024-0325-A3B7)
     * Generated by ReservationNumberGenerator
     */
    @Column(name = "reservation_number", nullable = false, unique = true, length = 20)
    private String reservationNumber;
    
    /**
     * Appointment date and time
     */
    @Column(name = "appointment_date", nullable = false)
    private LocalDateTime appointmentDate;
    
    /**
     * Accommodation check-in date
     */
    @Column(name = "check_in_date", nullable = false)
    private LocalDateTime checkInDate;
    
    /**
     * Accommodation check-out date
     */
    @Column(name = "check_out_date", nullable = false)
    private LocalDateTime checkOutDate;
    
    /**
     * Number of nights for accommodation
     */
    @Column(name = "number_of_nights", nullable = false)
    private Integer numberOfNights;
    
    /**
     * Total price - Calculated automatically via calculateTotal() method
     * Using BigDecimal for precision
     */
    @Column(name = "total_price", nullable = false, precision = 19, scale = 4)
    private BigDecimal totalPrice;
    
    /**
     * Currency code (ISO 4217)
     * Example: "EUR", "USD", "TRY", "GBP"
     * Required for international healthcare tourism
     */
    @Column(name = "currency", nullable = false, length = 3)
    private String currency = "EUR"; // Default currency
    
    /**
     * Reservation status - Enum for type safety
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 30)
    @Builder.Default
    private ReservationStatus status = ReservationStatus.PENDING;
    
    /**
     * Additional notes/comments
     */
    @Column(columnDefinition = "TEXT")
    private String notes;
    
    /**
     * Contact preference (email, phone, whatsapp)
     */
    @Column(name = "contact_preference", length = 50)
    private String contactPreference;
    
    /**
     * User ID (foreign key to user-service)
     * In microservice architecture, we use ID instead of @ManyToOne
     */
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    /**
     * Hospital ID (foreign key to hospital-service)
     */
    @Column(name = "hospital_id", nullable = false)
    private Long hospitalId;
    
    /**
     * Doctor ID (foreign key to doctor-service)
     */
    @Column(name = "doctor_id", nullable = false)
    private Long doctorId;
    
    /**
     * Accommodation ID (foreign key to accommodation-service)
     * Optional - some reservations may not include accommodation
     */
    @Column(name = "accommodation_id")
    private Long accommodationId;
    
    /**
     * Doctor consultation fee at time of reservation (snapshot)
     * Used for price calculations even if doctor's fee changes later
     */
    @Column(name = "doctor_fee_snapshot", precision = 10, scale = 2)
    private BigDecimal doctorFeeSnapshot;
    
    /**
     * Accommodation daily price at time of reservation (snapshot)
     * Used for price calculations even if accommodation price changes later
     */
    @Column(name = "accommodation_daily_price_snapshot", precision = 10, scale = 2)
    private BigDecimal accommodationDailyPriceSnapshot;
    
    /**
     * Calculate total price based on doctor fee and accommodation cost
     * 
     * Business Logic:
     * - Doctor consultation fee (one-time)
     * - Accommodation cost = dailyPrice * numberOfNights
     * - Total = doctorFee + accommodationCost
     * 
     * This method should be called before saving the reservation.
     */
    public void calculateTotal(BigDecimal doctorFee, BigDecimal accommodationDailyPrice) {
        if (doctorFee == null) {
            throw new IllegalArgumentException("Doctor fee cannot be null");
        }
        
        // Store snapshots for historical accuracy
        this.doctorFeeSnapshot = doctorFee;
        
        BigDecimal accommodationCost = BigDecimal.ZERO;
        if (accommodationDailyPrice != null && numberOfNights != null && numberOfNights > 0) {
            this.accommodationDailyPriceSnapshot = accommodationDailyPrice;
            accommodationCost = accommodationDailyPrice
                    .multiply(BigDecimal.valueOf(numberOfNights));
        }
        
        this.totalPrice = doctorFee.add(accommodationCost);
    }
    
    /**
     * Calculate total price using stored snapshots
     * Useful for recalculating without external service calls
     */
    public void calculateTotalFromSnapshots() {
        if (doctorFeeSnapshot == null) {
            throw new IllegalStateException("Doctor fee snapshot is not set");
        }
        
        BigDecimal accommodationCost = BigDecimal.ZERO;
        if (accommodationDailyPriceSnapshot != null && numberOfNights != null && numberOfNights > 0) {
            accommodationCost = accommodationDailyPriceSnapshot
                    .multiply(BigDecimal.valueOf(numberOfNights));
        }
        
        this.totalPrice = doctorFeeSnapshot.add(accommodationCost);
    }
    
    /**
     * Check if reservation can be cancelled
     */
    public boolean canBeCancelled() {
        return status != null && status.canBeCancelled();
    }
    
    /**
     * Check if reservation is in final state
     */
    public boolean isFinalState() {
        return status != null && status.isFinalState();
    }
    
    /**
     * Check if reservation allows refund
     */
    public boolean allowsRefund() {
        return status != null && status.allowsRefund();
    }
    
    /**
     * Cancel reservation
     * Business rule: Only PENDING or CONFIRMED reservations can be cancelled
     */
    public void cancel() {
        if (!canBeCancelled()) {
            throw new IllegalStateException(
                String.format("Reservation with status %s cannot be cancelled", status)
            );
        }
        this.status = ReservationStatus.CANCELLED;
    }
    
    /**
     * Confirm reservation
     * Business rule: Only PENDING reservations can be confirmed
     */
    public void confirm() {
        if (status != ReservationStatus.PENDING) {
            throw new IllegalStateException(
                String.format("Only PENDING reservations can be confirmed. Current status: %s", status)
            );
        }
        this.status = ReservationStatus.CONFIRMED;
    }
    
    /**
     * Mark as completed
     */
    public void complete() {
        if (status != ReservationStatus.CONFIRMED) {
            throw new IllegalStateException(
                String.format("Only CONFIRMED reservations can be completed. Current status: %s", status)
            );
        }
        this.status = ReservationStatus.COMPLETED;
    }
    
    /**
     * Mark as no-show
     */
    public void markAsNoShow() {
        if (status != ReservationStatus.CONFIRMED) {
            throw new IllegalStateException(
                String.format("Only CONFIRMED reservations can be marked as no-show. Current status: %s", status)
            );
        }
        this.status = ReservationStatus.NO_SHOW;
    }
    
    /**
     * Soft delete this entity
     */
    public void softDelete() {
        this.deleted = true;
    }
    
    /**
     * Restore a soft-deleted entity
     */
    public void restore() {
        this.deleted = false;
    }
    
    /**
     * Check if entity is deleted
     */
    public boolean isDeleted() {
        return Boolean.TRUE.equals(deleted);
    }
    
    /**
     * Pre-persist callback: Set default values
     */
    @PrePersist
    protected void onCreate() {
        if (deleted == null) {
            deleted = false;
        }
        if (status == null) {
            status = ReservationStatus.PENDING;
        }
        if (numberOfNights == null && checkInDate != null && checkOutDate != null) {
            // Calculate numberOfNights if not set
            numberOfNights = (int) java.time.Duration.between(checkInDate, checkOutDate).toDays();
        }
    }
    
    /**
     * Pre-update callback: Ensure data consistency
     */
    @PreUpdate
    protected void onUpdate() {
        // JPA Auditing will handle updatedAt automatically
        // Recalculate numberOfNights if dates changed
        if (checkInDate != null && checkOutDate != null) {
            long calculatedNights = java.time.Duration.between(checkInDate, checkOutDate).toDays();
            if (numberOfNights == null || numberOfNights != calculatedNights) {
                numberOfNights = (int) calculatedNights;
            }
        }
    }
}
